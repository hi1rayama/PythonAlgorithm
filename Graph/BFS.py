'''
幅優先探索：隣接している全てのノードに対して、1つずつ並列的に探索を進める方法。
          これにはキュー(先入先出法)が使用される。探索中の全てのノードに対して、隣接する
          未探索のノードが無くなったら探索を終了する

1. ノード1つ分の探索
        現在探索しているノードの隣接ノードの内、未探索のノード全てに対して、ノード1つ分の探索を行う

2. 探索を繰り返し及び終了
        手順1. によって探索が進められた全てのノードに対して、手順1. を繰り返し、全てのノードが探索された時、探索を終了

幅優先探索を使用する例
・始点から最も近いものを求めたい場合
・探索範囲自体は広いものの、ある程度近くに求めたい解が存在することがわかっている場合
・探索範囲が広く、深さ優先探索ではスタックが大量に使われてしまう場合

参考文献：http://enreco.hatenablog.com/entry/2016/09/15/090000
'''
##########################################グラフ探索を行う準備##########################################
# ノード
class Node:
    def __init__(self):
        self.start_node = None
        self.end_node = None


NODES = 9  # ノードの数
START = 0  # 探索開始ノード
edge_cnt = 0  # 木を構成するエッジとして登録されたエッジのカウンタ
bf_flag = [0 for i in range(NODES)]  # 探索状況[0:未探索, 1:探索済み] 初期値：0
TREE = [Node() for i in range(NODES - 1)]  # 探索木


lis = [[0, 1], [0, 3], [1, 2], [1, 3], [1, 4], [2, 5],
               [3, 6], [3, 7], [4, 5], [5, 7], [5, 8], [6, 7], [7, 8]]  # エッジ(隣接リスト)

matrix = [[0 for i in range(NODES)] for i in range(NODES)]  # エッジ(隣接行列)
for edge in lis:
    i, j = edge[0], edge[1]
    matrix[i][j] = 1
    matrix[j][i] = 1

##########################################main関数##########################################


def main():
    print("------------隣接行列------------")
    for m in matrix:
        print(m)
    bf_search(START)
    # 結果を表示する
    print("探索木")
    for node in TREE:
        print("({0},{1}) ".format(node.start_node, node.end_node))

##########################################幅優先探索を行う関数##########################################


def bf_search(nd):
    global edge_cnt
    queue=[0]*NODES
    bf_flag[nd] = 1  # ノードndを探索済みにする
    head=0
    tail=0

    queue[head]=nd
    head+=1

    while (head > tail):
        u=queue[tail]
        tail+=1
        for v in range(NODES):
            if(matrix[u][v] == 1 and bf_flag[v] == 0):  # 隣接しているノードでまだ探索していない場合
                TREE[edge_cnt].start_node = u #探索木に出発点を登録
                TREE[edge_cnt].end_node = v #探索木に到着点を登録
                edge_cnt += 1
                queue[head]=v
                head+=1
                bf_flag[v]=1



# 実行
main()

'''''''''''''''''''''''''''''''''
            結果
------------隣接行列------------
[0, 1, 0, 1, 0, 0, 0, 0, 0]
[1, 0, 1, 1, 1, 0, 0, 0, 0]
[0, 1, 0, 0, 0, 1, 0, 0, 0]
[1, 1, 0, 0, 0, 0, 1, 1, 0]
[0, 1, 0, 0, 0, 1, 0, 0, 0]
[0, 0, 1, 0, 1, 0, 0, 1, 1]
[0, 0, 0, 1, 0, 0, 0, 1, 0]
[0, 0, 0, 1, 0, 1, 1, 0, 1]
[0, 0, 0, 0, 0, 1, 0, 1, 0]
探索木
(0,1) 
(0,3) 
(1,2) 
(1,4) 
(3,6) 
(3,7) 
(2,5) 
(7,8)
'''''''''''''''''''''''''''''''''